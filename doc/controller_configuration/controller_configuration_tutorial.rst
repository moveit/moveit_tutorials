Low Level Controllers
=====================
There are a few paths for integrating a controller that moves robot joints with the MoveIt! framework, accommodating simple usage scenarios all the way to advanced customization:

* The `JointTrajectoryController <http://wiki.ros.org/joint_trajectory_controller>`_ and `GripperActionController <http://wiki.ros.org/gripper_action_controller>`_ from `ROS controllers <http://wiki.ros.org/ros_controllers>`_ package are supported out of the box because MoveIt implements integration interfaces and plugins that bridge them with MoveIt motion planning pipeline.
* Any other controllers managed by `ROS Controller Manager <http://wiki.ros.org/controller_manager>`_ can be used by linking them with an existing MoveIt integration plugin if they support `Follow Joint Trajectory Action <https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html>`_.
* ROS controllers that don't support `Follow Joint Trajectory Action <https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html>`_ can be bridged with MoveIt by implementing integration interfaces and exporting a plugin, as long as they can be made to fit into the `Controller Handle <https://docs.ros.org/en/noetic/api/moveit_core/html/classmoveit__controller__manager_1_1MoveItControllerHandle.html>`_ interface.
* Custom controllers that are not managed by `ROS Controller Manager <http://wiki.ros.org/controller_manager>`_, or for which the `MoveIt Controller Handle <https://docs.ros.org/en/noetic/api/moveit_core/html/classmoveit__controller__manager_1_1MoveItControllerHandle.html>`_ is a poor fit, can be integrated by writing a custom MoveIt Controller Manager.

We will look at each of these options in more detail.

Stock ROS Controllers
---------------------

The `JointTrajectoryController <http://wiki.ros.org/joint_trajectory_controller>`_ and `GripperActionController <http://wiki.ros.org/gripper_action_controller>`_ from `ROS controllers <http://wiki.ros.org/ros_controllers>`_ package are supported out of the box for simple usage scenarios, and can be easily configured by using the `MoveIt Setup Assistant <../setup_assistant/setup_assistant_tutorial.html>`_ (*MSA*) on the *Controllers* page.

These controllers are integrated with MoveIt by using existing `MoveIt Controller Handles <https://docs.ros.org/en/noetic/api/moveit_core/html/classmoveit__controller__manager_1_1MoveItControllerHandle.html>`_

* Stock `JointTrajectoryController <http://wiki.ros.org/joint_trajectory_controller>`_ is integrated through `Joint Trajectory Controller Handle <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/follow_joint_trajectory_controller_handle.h>`_.
* Stock `GripperActionController <http://wiki.ros.org/gripper_action_controller>`_ is integrated through `Gripper Controller Handle <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h>`_.

Controller Mapping
^^^^^^^^^^^^^^^^^^

The `ROS Controller Manager <http://wiki.ros.org/controller_manager>`_ loads these controllers from ``ros_controllers.yaml`` configuration file generated by MSA because they are `exported as plugins <https://github.com/ros-controls/ros_controllers/blob/noetic-devel/joint_trajectory_controller/ros_control_plugins.xml>`_ by the `ROS Controllers <http://wiki.ros.org/ros_controllers>`_ package using their ``type`` names:

.. code-block:: yaml

    arm_controller:
    type: velocity_controllers/JointTrajectoryController
    joints:
        - shoulder_joint
        - upperarm_joint
        - forearm_joint
    gains:
        shoulder_joint:
        p: 100
        d: 1
        i: 1
        i_clamp: 1
        upperarm_joint:
        p: 100
        d: 1
        i: 1
        i_clamp: 1
        forearm_joint:
        p: 100
        d: 1
        i: 1
        i_clamp: 1
    gripper_controller:
    type: position_controllers/GripperActionController
    joint: gripper

The *MoveIt Simple Controller Manager* configured by MSA `as the default <https://github.com/ros-planning/moveit/blob/master/moveit_setup_assistant/templates/moveit_config_pkg_template/launch/move_group.launch#L17>`_ will load the *handles* that bridge these controllers with MoveIt by reading the ``simple_moveit_controllers.yaml`` configuration file, for example:

.. code-block:: yaml

    controller_list:
    - name: arm_controller
        action_ns: follow_joint_trajectory
        type: FollowJointTrajectory
        default: True
        joints:
        - shoulder_joint
        - upperarm_joint
        - forearm_joint
    - name: gripper_controller
        action_ns: gripper_cmd
        type: GripperCommand
        default: True
        joints:
        - gripper

The mapping from ROS controller ``name`` to MoveIt *controller handle* ``type`` is done by using pre-defined *simple integration types*:

* ``FollowJointTrajectory``: specifying this integration type will bridge the ROS controller specified by the ``name`` setting to the MoveIt pipeline through the `Joint Trajectory Controller Handle <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/follow_joint_trajectory_controller_handle.h>`_.
* ``GripperCommand``: specifying this integration type will bridge the ROS controller specified by the ``name`` setting to the MoveIt pipeline through the `Gripper Controller Handle <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h>`_.

The ``action_ns`` setting specifies the *Action Server* topic exposed by the ROS controller. The full topic name consists of the ROS controller ``name`` and ``action_ns``. If you were to list topics by using ``rostopic list`` with the above two ROS controllers loaded, you would see something like the following: ::

/arm_controller/command
/arm_controller/follow_joint_trajectory/cancel
/arm_controller/follow_joint_trajectory/feedback
/arm_controller/follow_joint_trajectory/goal
/arm_controller/follow_joint_trajectory/result
/arm_controller/follow_joint_trajectory/status
/arm_controller/gains/forearm_joint/parameter_descriptions
/arm_controller/gains/forearm_joint/parameter_updates
/arm_controller/gains/shoulder_joint/parameter_descriptions
/arm_controller/gains/shoulder_joint/parameter_updates
/arm_controller/gains/upperarm_joint/parameter_descriptions
/arm_controller/gains/upperarm_joint/parameter_updates
/arm_controller/state
/gripper_controller/gripper_cmd/cancel
/gripper_controller/gripper_cmd/feedback
/gripper_controller/gripper_cmd/goal
/gripper_controller/gripper_cmd/result
/gripper_controller/gripper_cmd/status

Both controllers expose action servers under controller-specific topics like ``follow_joint_trajectory`` or ``gripper_cmd``.

Controller Settings
^^^^^^^^^^^^^^^^^^

The controlled joints are listed under the ``joints`` setting. MoveIt requires joint states for these joints to be published on the ``/joint_states`` topic to maintain its internal state representation of the robot, used as a starting state when executing a trajectory.

If the joint states are published on another topic specific to your project, such as ``/robot/joint_states``, add a ``remap`` to the ``move_group`` node in ``move_group.launch`` file generated by MSA:

.. code-block:: XML

    <!-- Start the actual move_group node/action server -->
    <node name="move_group" launch-prefix="$(arg launch_prefix)" pkg="moveit_ros_move_group" type="move_group" respawn="false" output="screen" args="$(arg command_args)">
        <remap
            from="joint_states"
            to="robot/joint_states"
        />
        <!-- Other settings -->
    </node>

The ``default`` setting is used to indicate a default controller that will be chosen to control this set of joints. This is useful when additional controllers are defined for the same joints:

* One such scenario is using the `Motion Planning RViz Plugin with a joystick <../joystick_control_teleoperation/joystick_control_teleoperation_tutorial.html?highlight=joystick>`_. In this case, ``JointGroupVelocityController`` or ``JointGroupPositionController`` could be configured in ``ros_controllers.yaml`` for the same set of joints.
* Another scenario is configuring the robot for use with `MoveIt Servo <../realtime_servo/realtime_servo_tutorial.html>`_ which lets you control the robot by using a joystick or a `SpaceMouse <https://3dconnexion.com/us/>`_. MoveIt Servo supports ``trajectory_msgs/JointTrajectory`` and ``std_msgs/Float64MultiArray`` so a ``JointGroupVelocityController`` or ``JointGroupPositionController`` could be configured as well.

Trajectory execution parameters can also be configured to fine-tune the allowed trajectory execution duration, overriding the global settings ``trajectory_execution/allowed_execution_duration_scaling`` and ``trajectory_execution/allowed_goal_duration_margin``.

* ``allowed_execution_duration_scaling`` - scales the allowed execution duration.
* ``allowed_goal_duration_margin`` - allows more than the expected execution time before triggering a trajectory cancel (applied after scaling).

.. note::
  Unlike the global settings, the controller-specific settings cannot be dynamically reconfigured at runtime.

Additional options for tuning the behavior and safety checks of the Move execution pipeline can be configured in ``trajectory_execution.launch.xml`` file generated by MSA:

* ``execution_duration_monitoring``: when ``false``, will not throw error if a controller takes longer than expected to complete a trajectory.
* ``allowed_goal_duration_margin``: same as above, but configured globally as a default for all controllers.
* ``allowed_start_tolerance``: joint state tolerance when validating that a trajectory's first point matches current robot state. If set to ``0`` MoveIt will skip waiting for the robot to stop after execution.

To test simple controller integration with *MoveIt Simple Controller Manager*, launch the package generated by MSA by using the ``move_group.launch`` file. This will load your robot description and the MoveIt motion planning pipeline hosted in ``move_group`` node from ``moveit_ros_move_group`` package.

.. note::
  This launch file assumes that your robot's `hardware interface <http://wiki.ros.org/ros_control/Tutorials/Create%20your%20own%20hardware%20interface>`_ is already running, since any ROS controllers you use will attempt to connect to this interface and send commands. It does not not include any `visualization <https://moveit.picknik.ai/main/doc/tutorials/quickstart_in_rviz/quickstart_in_rviz_tutorial.html>`_ and does not `simulate the hardware interface <https://classic.gazebosim.org/tutorials?tut=ros_control&cat=connect_ros>`_. In the absence of visualization and/or simulation tools, you can use the `C++ <https://moveit.picknik.ai/main/doc/examples/moveit_cpp/moveitcpp_tutorial.html>`_, `Python <https://moveit.picknik.ai/main/doc/examples/motion_planning_python_api/motion_planning_python_api_tutorial.html>`_, or `Command Line <../moveit_commander_scripting/moveit_commander_scripting_tutorial.html>`_ interface to interact with MoveIt.

ROS Controllers with Joint Trajectory Action
--------------------------------------------

The *MoveIt ROS Control Controller Manager* which is the default configured by MSA for visualizing and/or simulating the robot does not use the configuration in ``simple_moveit_controllers.yaml`` to discover controllers. Instead it queries `ROS Controller Manager <http://wiki.ros.org/controller_manager>`_ for loaded and active controllers.

Since this discovery process does not use the pre-defined types ``FollowJointTrajectory`` and ``GripperCommand`` (only supported by *Simple Controller Manager*), `Controller Handle Allocator <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/include/moveit_ros_control_interface/ControllerHandle.h>`_ plugins also need to be exported for each controller used in this fashion to link ROS controllers to MoveIt *Controller Handles* by their type names.

While `JointTrajectoryController <http://wiki.ros.org/joint_trajectory_controller>`_ from `ROS controllers <http://wiki.ros.org/ros_controllers>`_ is supported by *MoveIt ROS Control Controller Manager* out of the box because its `Controller Handle Allocator <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/src/joint_trajectory_controller_plugin.cpp>`_ is `exported <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/moveit_ros_control_interface_plugins.xml>`_ as a plugin, the `GripperActionController <http://wiki.ros.org/gripper_action_controller>`_ is not. Even though it has a `Controller Handle <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h>`_, it does not implement or export the corresponding *Controller Handle Allocator* plugin that enables the controller handle to be dynamically created from ROS controller type name. The next few sections will explain how to implement and export such a plugin.

.. note::
  In the specific case of *Gripper Action Controller*, the corresponding allocator is not exported because this controller is only used with *MoveIt Simple Controller Manager*. It ignores the commanded trajectory and simply sends the last point, thus it can only be used to open or close the gripper given the maximal force and does not provide fine-grained control over the trajectory. Advanced users configure one of the flavors of the Joint Trajectory Controller instead.

*Controller handles* implemented by MoveIt bridge ROS Controllers with the MoveIt motion planning pipeline by means of an `Action Client <http://wiki.ros.org/actionlib>`_, as long as the controller starts an *Action Server* that handles one of the two types of supported action interfaces:

* The `Joint Trajectory Controller Handle <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/follow_joint_trajectory_controller_handle.h>`_ plugin can be used for controllers that support `Follow Joint Trajectory Action <https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html>`_.
* The `Gripper Controller Handle <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h>`_ plugin can be used for controllers that support `Gripper Command Action <https://docs.ros.org/en/jade/api/control_msgs/html/action/GripperCommand.html>`_.

The *MoveIt ROS Control Controller Manager* will regard any controllers loaded by ROS Controller Manager as *managed* if it finds a plugin registration that links the ``type`` of the ROS controller with a MoveIt Controller Handle Allocator. If no such registration is found, the controller is regarded as *unmanaged* (merely *active*) and cannot be used to receive trajectory commands from MoveIt.

For example, see the stock Joint Trajectory Controller `plugin registration <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/moveit_ros_control_interface_plugins.xml>`_, which links several flavors of this controller exported from ``ros_controllers`` package with the corresponding MoveIt Controller Handle that supports `Follow Joint Trajectory Action <https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html>`_ via an exported MoveIt *Controller Handle Allocator* plugin.

The same pattern can be followed to link any other ROS controller with a MoveIt *Controller Handle* so that it can receive trajectory commands.

First, create a plugin description file:

.. code-block:: XML

    <library path="libmoveit_ros_control_interface_trajectory_plugin">
        <class
            name="controller_package_name/controller_type_name"
            type="moveit_ros_control_interface::JointTrajectoryControllerAllocator"
            base_class_type="moveit_ros_control_interface::ControllerHandleAllocator"
        >
            <description>
                Controller description
            </description>
        </class>
    </library>


Replace ``controller_package_name/controller_type_name`` and ``Controller description`` with values appropriate for your project.

Reference the plugin description in your package ``export`` section:

.. code-block:: XML

    <export>
        <moveit_ros_control_interface plugin="${prefix}/controller_moveit_plugin.xml"/>
    </export>

.. note::
    Replace ``/controller_moveit_plugin.xml`` with a relative path of the plugin description file created in the previous step.

After building the package, any controllers in ``ros_controllers.yaml`` that reference ``controller_package_name/controller_type_name`` will become available for use with MoveIt.

The *MoveIt ROS Control Controller Manager* can be configured by changing the ``moveit_controller_manager`` setting to ``ros_control``. The MoveIt configuration package auto-generated by MSA includes the `demo_gazebo.launch <https://github.com/ros-planning/moveit/blob/master/moveit_setup_assistant/templates/moveit_config_pkg_template/launch/demo_gazebo.launch#L19>`_ file that already configures this manager type in addition to launching `Gazebo <https://classic.gazebosim.org/tutorials?tut=ros_control&cat=connect_ros>`_ simulation and visualizing the robot state in `RViz <https://moveit.picknik.ai/main/doc/tutorials/quickstart_in_rviz/quickstart_in_rviz_tutorial.html>`_.

To test ROS controller integration with *MoveIt ROS Control Controller Manager*, launch the package generated by MSA by using the ``demo_gazebo.launch`` file. This will load your robot description, start the motion planning pipeline hosted in ``move_group`` node, and enable you to use the `Motion Planning Plugin <../quickstart_in_rviz/quickstart_in_rviz_tutorial.html>`_ in RViz to send goals to MoveIt, simulating the effect your ROS controllers will have on the real robot in Gazebo.

.. note::
  Since the ``GripperActionController`` is not supported by MoveIt ROS Control Controller Manager, it can be replaced in the above example by a flavor of ``JointTrajectoryController`` supported by your hardware, for example:

.. code-block:: yaml
    gripper_controller:
        type: position_controllers/JointTrajectoryController
        joints:
        - gripper

ROS Controllers with another interface
--------------------------------------

What if you need to use a ROS controller that does not support `Follow Joint Trajectory Action <https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html>`_ with *MoveIt ROS Control Controller Manager*? Some examples from `ROS controllers <http://wiki.ros.org/ros_controllers>`_ package include:

* `Gripper Action Controller <https://github.com/ros-controls/ros_controllers/blob/noetic-devel/gripper_action_controller/ros_control_plugins.xml>`_ discussed earlier
* `Joint Position and Joint Group Position <https://github.com/ros-controls/ros_controllers/blob/noetic-devel/position_controllers/position_controllers_plugins.xml>`_ Controllers
* `Joint Position, Joint Velocity, and Joint Group Velocity <https://github.com/ros-controls/ros_controllers/blob/noetic-devel/velocity_controllers/velocity_controllers_plugins.xml>`_ Controllers
* `Joint Position, Joint Velocity, Joint Effort, Joint Group Effort, and Joint Group Position <https://github.com/ros-controls/ros_controllers/blob/noetic-devel/effort_controllers/effort_controllers_plugins.xml>`_ Controllers

In this case, a *Controller Handle* and a *Controller Handle Allocator* may need to be implemented. The allocator will also need to be exported by your package as a plugin.

The following package dependencies are required for implementing controller handles and allocators:

* ``moveit_ros_control_interface`` - Provides base classes for controller handles and allocators
* ``pluginlib`` - Provides macros for exporting a class as a plugin, only needed to export the controller handle allocator

The ``actionlib`` package may also be needed for communicating with the ROS controller via an *Action Client* if it exposes an *Action Server*.

The following headers declare the relevant classes and macros:

* ``#include <moveit_ros_control_interface/ControllerHandle.h>``
  * declares ``moveit_controller_manager::MoveItControllerHandle`` class
  * declares ``moveit_ros_control_interface::ControllerHandleAllocator`` class
* ``#include <pluginlib/class_list_macros.h>``
  * declares ``PLUGINLIB_EXPORT_CLASS`` macro for exporting plugins

Two example *controller handle* implementations are included with MoveIt:

* `follow_joint_trajectory_controller_handle.h <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/follow_joint_trajectory_controller_handle.h>`_
  * See implementation in `follow_joint_trajectory_controller_handle.cpp <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/src/follow_joint_trajectory_controller_handle.cpp>`_
* `gripper_controller_handle.h <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h>`_
  * Implemented inline in the same header file

As you can see, writing a `controller handle <https://github.com/ros-planning/moveit/blob/master/moveit_core/controller_manager/include/moveit/controller_manager/controller_manager.h#L104>`_ comes down to implementing:
* ``sendTrajectory`` method that translates `moveit_msgs::RobotTrajectory <http://docs.ros.org/en/noetic/api/moveit_msgs/html/msg/RobotTrajectory.html>`_ to a format the controller can understand
* ``cancelExecution`` method to tell the controller to stop any active trajectories
* ``waitForExecution`` method that will block the calling thread until the controller finishes or the ``timeout`` is reached
* ``getLastExecutionStatus`` method that returns the status of the last requested trajectory.

One example *controller handle allocator* plugin implementation is included with MoveIt:

* `joint_trajectory_controller_plugin.cpp <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/src/joint_trajectory_controller_plugin.cpp>`_

The only job of a controller handle allocator is to create a new instance of the controller handle. The following example implements an allocator for a custom controller handle of type ``example::controller_handle_example``:

.. code-block:: c++

    #include "controller_handle_example.h" // the handle being allocated
    #include <moveit_ros_control_interface/ControllerHandle.h>
    #include <pluginlib/class_list_macros.h>

    namespace example
    {
    class controller_handle_allocator_example : public moveit_ros_control_interface::ControllerHandleAllocator
    {
    public:
    moveit_controller_manager::MoveItControllerHandlePtr alloc(const std::string& name,
                                                                const std::vector<std::string>& resources) override
    {
        return std::make_shared<controller_handle_example>(name, std::string("follow_joint_trajectory"));
    }
    };
    }  // namespace example

    PLUGINLIB_EXPORT_CLASS(example::controller_handle_allocator_example,
                        moveit_ros_control_interface::ControllerHandleAllocator);


This example controller handle allocator can be exported by creating a plugin definition file which is then referenced in the ``exports`` section of ``package.xml``:

.. code-block:: XML

    <library path="lib/libtrajectory_controller_example">
        <class
            name="example/trajectory_controller_example"
            type="example::controller_handle_allocator_example"
            base_class_type="moveit_ros_control_interface::ControllerHandleAllocator"
        >
            <description>
                Example Controller Handle Allocator for MoveIt!
            </description>
        </class>
    </library>

.. note::
  Replace ``lib/libtrajectory_controller_example`` with your library name by following the same format (prepending ``lib/lib`` to your library name)

This plugin definition links the name of a controller you are integrating with MoveIt (specified by the ``name`` attribute) with the type of the allocator you implemented (specified by the ``type`` attribute), such as the one in the example above.

The ``base_class_type`` must be set to ``moveit_ros_control_interface::ControllerHandleAllocator`` to make the allocator discoverable by MoveIt.

The plugin definition can then be referenced in the package manifest:

.. code-block:: XML

    <export>
        <!-- other exports... -->
        <moveit_ros_control_interface plugin="${prefix}/controller_handle_allocator_plugin.xml"/>
    </export>

The translation between `moveit_msgs::RobotTrajectory <http://docs.ros.org/en/noetic/api/moveit_msgs/html/msg/RobotTrajectory.html>`_ message and the type of command supported by the controller would be done by implementing a controller handle, for example:

.. code-block:: c++

      #pragma once

      #include <actionlib/client/simple_action_client.h>
      #include <control_msgs/FollowJointTrajectoryAction.h>
      #include <memory>
      #include <moveit_ros_control_interface/ControllerHandle.h>

      namespace example
      {
      class controller_handle_example : public moveit_controller_manager::MoveItControllerHandle
      {
      private:
        // Idle or done executing trajectory
        bool done_;

        // Connects to Action Server exposed by the controller
        std::shared_ptr<actionlib::SimpleActionClient<control_msgs::FollowJointTrajectoryAction>> actionClient_;

      public:
        controller_handle_example(const std::string& name, const std::string& action_ns)
        {
          std::string actionName = name + "/" + action_ns;

          actionClient_ =
              std::make_shared<actionlib::SimpleActionClient<control_msgs::FollowJointTrajectoryAction>>(actionName, true);

          actionClient_->waitForServer(ros::Duration(20.0));

          if (!actionClient_->isServerConnected())
          {
            // Report connection error
            actionClient_.reset();
          }
        }

      public:
        // MoveIt calls this method when it wants to send a trajectory goal to execute
        bool sendTrajectory(const moveit_msgs::RobotTrajectory& trajectory) override
        {
          if (!actionClient_)
          {
            // Report connection error
            return false;
          }

          control_msgs::FollowJointTrajectoryGoal goal;
          goal.trajectory = trajectory.joint_trajectory;

          actionClient_->sendGoal(
              goal,
              [this](const auto& state, const auto& result) {
                // Completed trajectory
                done_ = true;
              },
              [this] {
                // Beginning trajectory
              },
              [this](const auto& feedback) {
                // Trajectory feedback
              });

          done_ = false;

          return true;
        }

        // MoveIt calls this method when it wants a blocking call until done
        bool waitForExecution(const ros::Duration& timeout = ros::Duration(0)) override
        {
          if (actionClient_ && !done_)
            return actionClient_->waitForResult(ros::Duration(5.0));

          return true;
        }

        // MoveIt calls this method to get status updates
        moveit_controller_manager::ExecutionStatus getLastExecutionStatus() override
        {
          // Report last status here
          return moveit_controller_manager::ExecutionStatus::SUCCEEDED;
        }

        // MoveIt calls this method to abort trajectory goal execution
        bool cancelExecution() override
        {
          if (!actionClient_)
            return false;

          actionClient_->cancelGoal();
          done_ = true;

          return true;
        }
      };
      }  // namespace example

.. note::
   Replace ``your_controller_action`` with the type of action interface supported by the controller, and ``your_timeout`` with how long to wait for the connection to take place (this can be read from settings). If the controller doesn't support an Action Server, this can be replaced by whichever mechanism is supported.

Once implemented, the controller handle does not need to be exported, since it's returned by the controller handle allocator, which is exported.

Custom Controllers and Managers
-------------------------------

Custom controllers not managed by *ROS Controller Manager* can be integrated by implementing MoveIt *Controller Handle* and *Controller Handle Allocator* that conform to the MoveIt interface. Then they can be loaded by *MoveIt Simple Controller Manager* as described earlier in this topic.

If the `Controller Handle <https://docs.ros.org/en/noetic/api/moveit_core/html/classmoveit__controller__manager_1_1MoveItControllerHandle.html>`_ interface is a poor fit for your custom controller, a custom MoveIt Controller Manager can be written that will take care of loading or unloading the controller as well as managing its state and lifecycle.

Controller managers implemented and exported by MoveIt framework can be used as examples when implementing a custom controller manager plugin:

* `Test MoveIt Controller Manager <https://github.com/ros-planning/moveit/blob/master/moveit_ros/planning/trajectory_execution_manager/test/test_moveit_controller_manager_plugin.cpp>`_ - a bare bones example of what it takes to implement a MoveIt Controller Manager plugin.
* `MoveIt Fake Controller Manager <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_fake_controller_manager/src/moveit_fake_controller_manager.cpp>`_ - `exported <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_fake_controller_manager/moveit_fake_controller_manager_plugin_description.xml>`_ by ``moveit_plugins`` package and configured by ``demo.launch`` file generated by MSA to preview the visual effect the chosen controllers would have on the robot by launching RViz with Motion Planning plugin, but without simulating robot hardware.
* `MoveIt Simple Controller Manager <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/src/moveit_simple_controller_manager.cpp>`_ - `exported <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/moveit_simple_controller_manager_plugin_description.xml>`_ by ``moveit_plugins`` package. Configured as the default by ``move_group.launch`` file which is auto-generated by MSA, but can also be used for simulation, visualization, or with real robot hardware. Described in detail in previous sections.
* `MoveIt ROS Control Controller Manager <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/src/controller_manager_plugin.cpp>`_ - `exported <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/moveit_core_plugins.xml>`_ by ``moveit_plugins`` package. Discussed in detail in the previous section. Configured by the ``demo_gazebo.launch`` file which is auto-generated by MSA.
* `MoveIt Multi Controller Manager <https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/src/controller_manager_plugin.cpp#L374>`_ - supports multiple running ``ros_control`` nodes for advanced scenarios. Keeps track of which controller belongs to which node.

While *MoveIt Simple Controller Manager* and *MoveIt ROS Control Controller Manager* have been covered extensively, this topic has not focused on *Fake* and *Multi* controller managers up to this point. These controllers are described next.

Fake Controller Manager
^^^^^^^^^^^^^^^^^^^^^^^

MoveIt comes with a series of fake trajectory controllers that can be used for simulations. For example, the ``demo.launch`` file generated by MSA employs fake controllers for nice visualization in RViz.

The configuration for these controllers is stored in ``fake_controllers.yaml`` also generated by MSA, for example:

.. code-block:: yaml

    controller_list:
    - name: fake_arm_controller
        type: $(arg fake_execution_type)
        joints:
        - shoulder_joint
        - upperarm_joint
        - forearm_joint
    - name: fake_gripper_controller
        type: $(arg fake_execution_type)
        joints:
        - gripper
    initial:  # Define initial robot poses per group
    - group: arm
        pose: ready
    - group: gripper
        pose: open

The ``type`` setting specifies the *fake controller type*:

* ``interpolate``: performs smooth interpolation between trajectory waypoints - the default for visualization.
* ``via points``: jumps to the position specified by each trajectory waypoint without interpolation in between - useful for visual debugging.
* ``last point``: warps directly to the last trajectory waypoint - the fastest method for off-line benchmarking.

Multi Controller Manager
^^^^^^^^^^^^^^^^^^^^^^^^

The *MoveIt Multi Controller Manager* can be used when more than one ``ros_control`` node is employed. It works by creating multiple *MoveIt ROS Control Controller Managers*, one for each node. It instantiates them with their respective namespace and takes care of proper delegation. This type of manager can be configured by setting ``moveit_controller_manager`` to ``moveit_ros_control_interface::MoveItMultiControllerManager``:

.. code-block:: XML

    <param name="moveit_controller_manager" value="moveit_ros_control_interface::MoveItMultiControllerManager" />

Controller Switching and Namespaces
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

All controller names get prefixed by the namespace of their ``ros_control`` node. For this reason, controller names should not contain slashes, and canâ€™t be named ``/``. 

Joints are claimed by each controller during initialization or startup. ROS controllers receive a hardware interface of the type they support (position, velocity, or effort), which they can use to request a *joint handle* for each joint they are configured to control. The act of requesting a joint handle will cause the *ROS Controller Manager* to record that a particular joint was *claimed* as a *resource* by a particular controller.

For a particular ``ros_control`` node, MoveIt can decide which controllers to start or stop. Since only *managed controllers* (the ones with registered *controller handle allocator* plugins) are handled by MoveIt, it will take care of stopping controllers based on their *claimed resources* if a to-be-started controller needs any of those resources.
